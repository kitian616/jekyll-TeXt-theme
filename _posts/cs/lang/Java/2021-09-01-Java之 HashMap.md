---
tags: Java HashMap
categories:
  - cs
  - lang
  - java
---



# Java之 HashMap

# 数据结构背景

在已经众所周知的线性表、树等数据结构中，记录存储在结构中的相对位置是随机的，因而相应的检索是通过若干次的比较以寻找指定的记录。为了对此进行优化——`散列存储`应运而生，`它既是一种存储方式，又是一种常见的检索方法`。

 ## Hash表(Hash table)
 也叫**散列表**。在`顺序`、`折半`、`分块查找`和`二叉排序树`的查找中，其`ASL(Average Search Length)`的量级在O(n)～O(log2n)之间。不论ASL在哪个量级，都与`记录长度n`有关。随着n的扩大，算法的效率会越来越低。ASL与n有关是因为记录在存储器中的存放是随机的，或者说`记录的key与记录的存放地址无关`，因而查找`只能建立在key的“比较”基础上`。

理想的查找方法是：**对给定的k，不经任何多余的比较便能获取所需的记录，其查找的时间复杂度为常数级O(1)。** Hash表就是为此而诞生的。

## 散列函数
若在建立记录表的时候，确定记录的key与其存储地址之间的关系f，即使key与记录的存放地址H相对应：
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/wholon/image@main/uPic/9dbb1f36e448427c80622e02e191fff6.png)
记录按key存放。当要查找key=k的记录时，通过关系f就可得到相应记录的地址而获取记录，从而省去key的比较过程。这个关系f就是所谓的Hash函数（或称散列函数），记为H(key)。它实际上是一个地址映射函数，其自变量为记录的key，函数值为记录的存储地址（或称Hash地址）。

## 散列存储
散列存储的基本思想：
以关键字的值为自变量，通过一定的函数关系（散列函数，或称Hash函数），以计算得到的函数值作为结点的存储地址（编号，即数组的下标），将结点存入相应的存储单元里去。 

![散列存储过程示例](https://cdn.jsdelivr.net/gh/wholon/image@main/uPic/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASG9sb25f,size_20,color_FFFFFF,t_70,g_se,x_16-20211105002314866.png)
## 冲突、同义词的概念
散列存储中经常会出现对于两个不同关键字xi，xj，却有H(xi)=H(xj)，即对于不同的关键字具有相同的存放地址，这种现象称为冲突或碰撞。碰撞的两个（或多个）关键字称为同义词（相对于函数H而言）。 

## 装填因子
又称“负载因子”反映了散列表的装填程度（饱和程度）其定义为：
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/wholon/image@main/uPic/245a19c182a84e7d812b85ea79212428.png)
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/wholon/image@main/uPic/dddae6c12bea4a4aa72e656f2a69b337.png)
通常a<1，负载因子越接近1.0，内存的使用效率越高，元素的寻找时间越长，同样，负载因子越接近0.0，元素的寻找时间越短，但内存的浪费越大。

## 散列函数的构造
常用的有6种方法：
       数字选择法
       平方取中法
       折叠法
       除留余数法
       直接定址法
       随机数法

## 处理冲突的方法
在地址j的前面或后面找一个空闲单元存   
 放冲突的记录，或将相冲突的各记录拉成链表等等。
 堆积：散列地址不同的结点争夺同一个后继散列地址的现象称为“堆积”，它严重影响了Hash表的查找效率。
冲突现象的发生有时并不完全是由于Hash函数的随机性不好引起的，堆积的发生也会加重冲突。
堆积的另一个因素是表的装填因子α，α=n/m，其中m为表长，n为表中记录个数。一般α在0.65～0.9之间，使表保持一定的空闲余量，以减少冲突和堆积现象。
处理冲突的方法也有多种，下面我们讨论其中两种较常用的方法。 

### 开放地址法
   当发生冲突时，在H(key)的前后找一个空闲单元来存放冲突的记录，即在H(key)的基础上获取下一地址：
                         Hi=(H(key)+di)%m
   其中m为表长，%运算是保证Hi落在[0，m-l]区间；di为地址增量。di的取法有多种：
（1）di= 1，2，……,(m-1)-d, -d,  -d+1,…,-1—称为线性探查法；   
          Hi：d+1,d+2, …., m-1,    0,      1,    …,d-1.
（2）di=12，-12，22，-22，……——称为二次探查法。
    式（1）、(2)表示：第1次发生冲突时，地址增量d1取12；再冲突时，d2取-l2，……，依此类推。

### 拉链法
发生冲突时，将各冲突记录链在一起，即同义词的记录存在同一个链表中。
设H(key)取值范围（值域）为[0，m-l]，建立头指针数组HP[m]，HP[i]（0≤i≤m-l）初值为空。凡H(key)==i的记录都链入头指针为HP[i]的链表。

  拉链法解决冲突的优点：
无堆积现象,平均查找长度较短；
适合于构造表之前无法准确确定表长m的情况；
删除表中记录容易实现。而开放地址法的Hash表作删除时，不能将记录所在单元置空，只能作删除标记，否则将截断在它之后填入散列表的同义词结点的查找路径，因为开放地址法中，空单元是查找失败的条件。 
 拉链法的缺点：
 指针需要占用额外的空间，故当结点规模较小时，开放地址法较为节省空间。 
 当装填因子α较大时，拉链法所用的空间比开放地址法多，但是因子越大，开放地址法需要的探测次数越多。因此空间和效率往往是一对矛盾体。

# 具体语言实现
## Java